# coding: utf-8

"""
    Bandwidth

    Bandwidth's Communication APIs

    The version of the OpenAPI document: 1.0.0
    Contact: letstalk@bandwidth.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictStr

from typing import List, Optional, Union

from bandwidth.models.call_recording_metadata import CallRecordingMetadata
from bandwidth.models.transcribe_recording import TranscribeRecording
from bandwidth.models.transcription_list import TranscriptionList
from bandwidth.models.update_call_recording import UpdateCallRecording

from bandwidth.api_client import ApiClient
from bandwidth.api_response import ApiResponse
from bandwidth.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class RecordingsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def delete_call_transcription(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> None:  # noqa: E501
        """Delete Transcription  # noqa: E501

        Deletes the specified recording's transcription.  Note: After the deletion is requested and a `204` is returned, the transcription will not be accessible anymore. However, it is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_call_transcription(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the delete_call_transcription_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.delete_call_transcription_with_http_info(account_id, call_id, recording_id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_call_transcription_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete Transcription  # noqa: E501

        Deletes the specified recording's transcription.  Note: After the deletion is requested and a `204` is returned, the transcription will not be accessible anymore. However, it is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_call_transcription_with_http_info(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _hosts = [
            'https://voice.bandwidth.com/api/v2'
        ]
        _host = _hosts[0]
        if kwargs.get('_host_index'):
            _host_index = int(kwargs.get('_host_index'))
            if _host_index < 0 or _host_index >= len(_hosts):
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s"
                    % len(_host)
                )
            _host = _hosts[_host_index]
        _params = locals()

        _all_params = [
            'account_id',
            'call_id',
            'recording_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params and _key != "_host_index":
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_call_transcription" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountId'] = _params['account_id']

        if _params['call_id']:
            _path_params['callId'] = _params['call_id']

        if _params['recording_id']:
            _path_params['recordingId'] = _params['recording_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Basic']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/accounts/{accountId}/calls/{callId}/recordings/{recordingId}/transcription', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            _host=_host,
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_recording(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> None:  # noqa: E501
        """Delete Recording  # noqa: E501

        Delete the recording information, media and transcription.  Note: After the deletion is requested and a `204` is returned, neither the recording metadata nor the actual media nor its transcription will be accessible anymore. However, the media of the specified recording is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_recording(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the delete_recording_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.delete_recording_with_http_info(account_id, call_id, recording_id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_recording_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete Recording  # noqa: E501

        Delete the recording information, media and transcription.  Note: After the deletion is requested and a `204` is returned, neither the recording metadata nor the actual media nor its transcription will be accessible anymore. However, the media of the specified recording is not deleted immediately. This deletion process, while transparent and irreversible, can take an additional 24 to 48 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_recording_with_http_info(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _hosts = [
            'https://voice.bandwidth.com/api/v2'
        ]
        _host = _hosts[0]
        if kwargs.get('_host_index'):
            _host_index = int(kwargs.get('_host_index'))
            if _host_index < 0 or _host_index >= len(_hosts):
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s"
                    % len(_host)
                )
            _host = _hosts[_host_index]
        _params = locals()

        _all_params = [
            'account_id',
            'call_id',
            'recording_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params and _key != "_host_index":
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_recording" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountId'] = _params['account_id']

        if _params['call_id']:
            _path_params['callId'] = _params['call_id']

        if _params['recording_id']:
            _path_params['recordingId'] = _params['recording_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Basic']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/accounts/{accountId}/calls/{callId}/recordings/{recordingId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            _host=_host,
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_recording_media(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> None:  # noqa: E501
        """Delete Recording Media  # noqa: E501

        Deletes the specified recording's media.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_recording_media(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the delete_recording_media_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.delete_recording_media_with_http_info(account_id, call_id, recording_id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_recording_media_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete Recording Media  # noqa: E501

        Deletes the specified recording's media.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_recording_media_with_http_info(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _hosts = [
            'https://voice.bandwidth.com/api/v2'
        ]
        _host = _hosts[0]
        if kwargs.get('_host_index'):
            _host_index = int(kwargs.get('_host_index'))
            if _host_index < 0 or _host_index >= len(_hosts):
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s"
                    % len(_host)
                )
            _host = _hosts[_host_index]
        _params = locals()

        _all_params = [
            'account_id',
            'call_id',
            'recording_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params and _key != "_host_index":
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_recording_media" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountId'] = _params['account_id']

        if _params['call_id']:
            _path_params['callId'] = _params['call_id']

        if _params['recording_id']:
            _path_params['recordingId'] = _params['recording_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Basic']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/accounts/{accountId}/calls/{callId}/recordings/{recordingId}/media', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            _host=_host,
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def download_call_recording(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> bytearray:  # noqa: E501
        """Download Recording  # noqa: E501

        Downloads the specified recording.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.download_call_recording(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the download_call_recording_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.download_call_recording_with_http_info(account_id, call_id, recording_id, **kwargs)  # noqa: E501

    @validate_arguments
    def download_call_recording_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Download Recording  # noqa: E501

        Downloads the specified recording.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.download_call_recording_with_http_info(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _hosts = [
            'https://voice.bandwidth.com/api/v2'
        ]
        _host = _hosts[0]
        if kwargs.get('_host_index'):
            _host_index = int(kwargs.get('_host_index'))
            if _host_index < 0 or _host_index >= len(_hosts):
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s"
                    % len(_host)
                )
            _host = _hosts[_host_index]
        _params = locals()

        _all_params = [
            'account_id',
            'call_id',
            'recording_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params and _key != "_host_index":
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_call_recording" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountId'] = _params['account_id']

        if _params['call_id']:
            _path_params['callId'] = _params['call_id']

        if _params['recording_id']:
            _path_params['recordingId'] = _params['recording_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['audio/vnd.wave', 'audio/mpeg', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Basic']  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '400': "VoiceApiError",
            '401': "VoiceApiError",
            '403': "VoiceApiError",
            '404': "VoiceApiError",
            '405': "VoiceApiError",
            '415': "VoiceApiError",
            '429': "VoiceApiError",
            '500': "VoiceApiError",
        }

        return self.api_client.call_api(
            '/accounts/{accountId}/calls/{callId}/recordings/{recordingId}/media', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            _host=_host,
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_call_recording(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> CallRecordingMetadata:  # noqa: E501
        """Get Call Recording  # noqa: E501

        Returns metadata for the specified recording.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_call_recording(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CallRecordingMetadata
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_call_recording_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_call_recording_with_http_info(account_id, call_id, recording_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_call_recording_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Call Recording  # noqa: E501

        Returns metadata for the specified recording.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_call_recording_with_http_info(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CallRecordingMetadata, status_code(int), headers(HTTPHeaderDict))
        """

        _hosts = [
            'https://voice.bandwidth.com/api/v2'
        ]
        _host = _hosts[0]
        if kwargs.get('_host_index'):
            _host_index = int(kwargs.get('_host_index'))
            if _host_index < 0 or _host_index >= len(_hosts):
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s"
                    % len(_host)
                )
            _host = _hosts[_host_index]
        _params = locals()

        _all_params = [
            'account_id',
            'call_id',
            'recording_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params and _key != "_host_index":
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_call_recording" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountId'] = _params['account_id']

        if _params['call_id']:
            _path_params['callId'] = _params['call_id']

        if _params['recording_id']:
            _path_params['recordingId'] = _params['recording_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Basic']  # noqa: E501

        _response_types_map = {
            '200': "CallRecordingMetadata",
            '400': "VoiceApiError",
            '401': "VoiceApiError",
            '403': "VoiceApiError",
            '404': "VoiceApiError",
            '405': "VoiceApiError",
            '415': "VoiceApiError",
            '429': "VoiceApiError",
            '500': "VoiceApiError",
        }

        return self.api_client.call_api(
            '/accounts/{accountId}/calls/{callId}/recordings/{recordingId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            _host=_host,
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_call_transcription(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> TranscriptionList:  # noqa: E501
        """Get Transcription  # noqa: E501

        Downloads the specified transcription.  If the transcribed recording was multi-channel, then there will be 2 transcripts. The caller/called party transcript will be the first item while [`<PlayAudio>`](/docs/voice/bxml/playAudio) and [`<SpeakSentence>`](/docs/voice/bxml/speakSentence) transcript will be the second item. During a [`<Transfer>`](/docs/voice/bxml/transfer) the A-leg transcript will be the first item while the B-leg transcript will be the second item.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_call_transcription(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TranscriptionList
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_call_transcription_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_call_transcription_with_http_info(account_id, call_id, recording_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_call_transcription_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get Transcription  # noqa: E501

        Downloads the specified transcription.  If the transcribed recording was multi-channel, then there will be 2 transcripts. The caller/called party transcript will be the first item while [`<PlayAudio>`](/docs/voice/bxml/playAudio) and [`<SpeakSentence>`](/docs/voice/bxml/speakSentence) transcript will be the second item. During a [`<Transfer>`](/docs/voice/bxml/transfer) the A-leg transcript will be the first item while the B-leg transcript will be the second item.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_call_transcription_with_http_info(account_id, call_id, recording_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TranscriptionList, status_code(int), headers(HTTPHeaderDict))
        """

        _hosts = [
            'https://voice.bandwidth.com/api/v2'
        ]
        _host = _hosts[0]
        if kwargs.get('_host_index'):
            _host_index = int(kwargs.get('_host_index'))
            if _host_index < 0 or _host_index >= len(_hosts):
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s"
                    % len(_host)
                )
            _host = _hosts[_host_index]
        _params = locals()

        _all_params = [
            'account_id',
            'call_id',
            'recording_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params and _key != "_host_index":
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_call_transcription" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountId'] = _params['account_id']

        if _params['call_id']:
            _path_params['callId'] = _params['call_id']

        if _params['recording_id']:
            _path_params['recordingId'] = _params['recording_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Basic']  # noqa: E501

        _response_types_map = {
            '200': "TranscriptionList",
            '400': "VoiceApiError",
            '401': "VoiceApiError",
            '403': "VoiceApiError",
            '404': "VoiceApiError",
            '405': "VoiceApiError",
            '415': "VoiceApiError",
            '429': "VoiceApiError",
            '500': "VoiceApiError",
        }

        return self.api_client.call_api(
            '/accounts/{accountId}/calls/{callId}/recordings/{recordingId}/transcription', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            _host=_host,
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_account_call_recordings(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], to : Annotated[Optional[StrictStr], Field(description="Filter results by the `to` field.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="Filter results by the `from` field.")] = None, min_start_time : Annotated[Optional[StrictStr], Field(description="Filter results to recordings which have a `startTime` after or including `minStartTime` (in ISO8601 format).")] = None, max_start_time : Annotated[Optional[StrictStr], Field(description="Filter results to recordings which have a `startTime` before `maxStartTime` (in ISO8601 format).")] = None, **kwargs) -> List[CallRecordingMetadata]:  # noqa: E501
        """Get Call Recordings  # noqa: E501

        Returns a list of metadata for the recordings associated with the specified account. The list can be filtered by the optional from, to, minStartTime, and maxStartTime arguments. The list is capped at 1000 entries and may be empty if no recordings match the specified criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_account_call_recordings(account_id, to, var_from, min_start_time, max_start_time, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param to: Filter results by the `to` field.
        :type to: str
        :param var_from: Filter results by the `from` field.
        :type var_from: str
        :param min_start_time: Filter results to recordings which have a `startTime` after or including `minStartTime` (in ISO8601 format).
        :type min_start_time: str
        :param max_start_time: Filter results to recordings which have a `startTime` before `maxStartTime` (in ISO8601 format).
        :type max_start_time: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[CallRecordingMetadata]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_account_call_recordings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_account_call_recordings_with_http_info(account_id, to, var_from, min_start_time, max_start_time, **kwargs)  # noqa: E501

    @validate_arguments
    def list_account_call_recordings_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], to : Annotated[Optional[StrictStr], Field(description="Filter results by the `to` field.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="Filter results by the `from` field.")] = None, min_start_time : Annotated[Optional[StrictStr], Field(description="Filter results to recordings which have a `startTime` after or including `minStartTime` (in ISO8601 format).")] = None, max_start_time : Annotated[Optional[StrictStr], Field(description="Filter results to recordings which have a `startTime` before `maxStartTime` (in ISO8601 format).")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Call Recordings  # noqa: E501

        Returns a list of metadata for the recordings associated with the specified account. The list can be filtered by the optional from, to, minStartTime, and maxStartTime arguments. The list is capped at 1000 entries and may be empty if no recordings match the specified criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_account_call_recordings_with_http_info(account_id, to, var_from, min_start_time, max_start_time, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param to: Filter results by the `to` field.
        :type to: str
        :param var_from: Filter results by the `from` field.
        :type var_from: str
        :param min_start_time: Filter results to recordings which have a `startTime` after or including `minStartTime` (in ISO8601 format).
        :type min_start_time: str
        :param max_start_time: Filter results to recordings which have a `startTime` before `maxStartTime` (in ISO8601 format).
        :type max_start_time: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[CallRecordingMetadata], status_code(int), headers(HTTPHeaderDict))
        """

        _hosts = [
            'https://voice.bandwidth.com/api/v2'
        ]
        _host = _hosts[0]
        if kwargs.get('_host_index'):
            _host_index = int(kwargs.get('_host_index'))
            if _host_index < 0 or _host_index >= len(_hosts):
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s"
                    % len(_host)
                )
            _host = _hosts[_host_index]
        _params = locals()

        _all_params = [
            'account_id',
            'to',
            'var_from',
            'min_start_time',
            'max_start_time'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params and _key != "_host_index":
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_account_call_recordings" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountId'] = _params['account_id']


        # process the query parameters
        _query_params = []
        if _params.get('to') is not None:  # noqa: E501
            _query_params.append(('to', _params['to']))

        if _params.get('var_from') is not None:  # noqa: E501
            _query_params.append(('from', _params['var_from']))

        if _params.get('min_start_time') is not None:  # noqa: E501
            _query_params.append(('minStartTime', _params['min_start_time']))

        if _params.get('max_start_time') is not None:  # noqa: E501
            _query_params.append(('maxStartTime', _params['max_start_time']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Basic']  # noqa: E501

        _response_types_map = {
            '200': "List[CallRecordingMetadata]",
            '400': "VoiceApiError",
            '401': "VoiceApiError",
            '403': "VoiceApiError",
            '404': "VoiceApiError",
            '405': "VoiceApiError",
            '415': "VoiceApiError",
            '429': "VoiceApiError",
            '500': "VoiceApiError",
        }

        return self.api_client.call_api(
            '/accounts/{accountId}/recordings', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            _host=_host,
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_call_recordings(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], **kwargs) -> List[CallRecordingMetadata]:  # noqa: E501
        """List Call Recordings  # noqa: E501

        Returns a (potentially empty) list of metadata for the recordings that took place during the specified call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_call_recordings(account_id, call_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[CallRecordingMetadata]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_call_recordings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_call_recordings_with_http_info(account_id, call_id, **kwargs)  # noqa: E501

    @validate_arguments
    def list_call_recordings_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], **kwargs) -> ApiResponse:  # noqa: E501
        """List Call Recordings  # noqa: E501

        Returns a (potentially empty) list of metadata for the recordings that took place during the specified call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_call_recordings_with_http_info(account_id, call_id, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[CallRecordingMetadata], status_code(int), headers(HTTPHeaderDict))
        """

        _hosts = [
            'https://voice.bandwidth.com/api/v2'
        ]
        _host = _hosts[0]
        if kwargs.get('_host_index'):
            _host_index = int(kwargs.get('_host_index'))
            if _host_index < 0 or _host_index >= len(_hosts):
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s"
                    % len(_host)
                )
            _host = _hosts[_host_index]
        _params = locals()

        _all_params = [
            'account_id',
            'call_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params and _key != "_host_index":
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_call_recordings" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountId'] = _params['account_id']

        if _params['call_id']:
            _path_params['callId'] = _params['call_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Basic']  # noqa: E501

        _response_types_map = {
            '200': "List[CallRecordingMetadata]",
            '400': "VoiceApiError",
            '401': "VoiceApiError",
            '403': "VoiceApiError",
            '404': "VoiceApiError",
            '405': "VoiceApiError",
            '415': "VoiceApiError",
            '429': "VoiceApiError",
            '500': "VoiceApiError",
        }

        return self.api_client.call_api(
            '/accounts/{accountId}/calls/{callId}/recordings', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            _host=_host,
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def transcribe_call_recording(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], transcribe_recording : TranscribeRecording, **kwargs) -> None:  # noqa: E501
        """Create Transcription Request  # noqa: E501

        Generate the transcription for a specific recording. Transcription can succeed only for recordings of length greater than 500 milliseconds and less than 4 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.transcribe_call_recording(account_id, call_id, recording_id, transcribe_recording, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param transcribe_recording: (required)
        :type transcribe_recording: TranscribeRecording
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the transcribe_call_recording_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.transcribe_call_recording_with_http_info(account_id, call_id, recording_id, transcribe_recording, **kwargs)  # noqa: E501

    @validate_arguments
    def transcribe_call_recording_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], recording_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Recording ID.")], transcribe_recording : TranscribeRecording, **kwargs) -> ApiResponse:  # noqa: E501
        """Create Transcription Request  # noqa: E501

        Generate the transcription for a specific recording. Transcription can succeed only for recordings of length greater than 500 milliseconds and less than 4 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.transcribe_call_recording_with_http_info(account_id, call_id, recording_id, transcribe_recording, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param recording_id: Programmable Voice API Recording ID. (required)
        :type recording_id: str
        :param transcribe_recording: (required)
        :type transcribe_recording: TranscribeRecording
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _hosts = [
            'https://voice.bandwidth.com/api/v2'
        ]
        _host = _hosts[0]
        if kwargs.get('_host_index'):
            _host_index = int(kwargs.get('_host_index'))
            if _host_index < 0 or _host_index >= len(_hosts):
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s"
                    % len(_host)
                )
            _host = _hosts[_host_index]
        _params = locals()

        _all_params = [
            'account_id',
            'call_id',
            'recording_id',
            'transcribe_recording'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params and _key != "_host_index":
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcribe_call_recording" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountId'] = _params['account_id']

        if _params['call_id']:
            _path_params['callId'] = _params['call_id']

        if _params['recording_id']:
            _path_params['recordingId'] = _params['recording_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['transcribe_recording'] is not None:
            _body_params = _params['transcribe_recording']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Basic']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/accounts/{accountId}/calls/{callId}/recordings/{recordingId}/transcription', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            _host=_host,
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_call_recording_state(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], update_call_recording : UpdateCallRecording, **kwargs) -> None:  # noqa: E501
        """Update Recording  # noqa: E501

        Pause or resume a recording on an active phone call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_call_recording_state(account_id, call_id, update_call_recording, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param update_call_recording: (required)
        :type update_call_recording: UpdateCallRecording
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the update_call_recording_state_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.update_call_recording_state_with_http_info(account_id, call_id, update_call_recording, **kwargs)  # noqa: E501

    @validate_arguments
    def update_call_recording_state_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="Your Bandwidth Account ID.")], call_id : Annotated[StrictStr, Field(..., description="Programmable Voice API Call ID.")], update_call_recording : UpdateCallRecording, **kwargs) -> ApiResponse:  # noqa: E501
        """Update Recording  # noqa: E501

        Pause or resume a recording on an active phone call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_call_recording_state_with_http_info(account_id, call_id, update_call_recording, async_req=True)
        >>> result = thread.get()

        :param account_id: Your Bandwidth Account ID. (required)
        :type account_id: str
        :param call_id: Programmable Voice API Call ID. (required)
        :type call_id: str
        :param update_call_recording: (required)
        :type update_call_recording: UpdateCallRecording
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _hosts = [
            'https://voice.bandwidth.com/api/v2'
        ]
        _host = _hosts[0]
        if kwargs.get('_host_index'):
            _host_index = int(kwargs.get('_host_index'))
            if _host_index < 0 or _host_index >= len(_hosts):
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s"
                    % len(_host)
                )
            _host = _hosts[_host_index]
        _params = locals()

        _all_params = [
            'account_id',
            'call_id',
            'update_call_recording'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params and _key != "_host_index":
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_call_recording_state" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountId'] = _params['account_id']

        if _params['call_id']:
            _path_params['callId'] = _params['call_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_call_recording'] is not None:
            _body_params = _params['update_call_recording']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Basic']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/accounts/{accountId}/calls/{callId}/recording', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            _host=_host,
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
